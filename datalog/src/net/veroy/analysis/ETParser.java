package net.veroy.analysis;


//import net.veroy.guava.benchmark.cache.ObjectRecord;
//import net.veroy.guava.benchmark.cache.UpdateRecord;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.nio.charset.Charset;

import java.util.ArrayList;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.HashMap;

import org.deri.iris.api.IKnowledgeBase;
import org.deri.iris.api.basics.IQuery;
import org.deri.iris.api.terms.IVariable;
import org.deri.iris.compiler.Parser;
import org.deri.iris.compiler.ParserException;
import org.deri.iris.storage.IRelation;

public class ETParser {

    static HashMap<Integer, ObjectModel> heap;

    public static void processInput(Parser p) {
	heap = new HashMap<Integer, ObjectModel>();

        try {
            int i = 0;
            String line;
            try (
                  InputStreamReader isr = new InputStreamReader(System.in, Charset.forName("UTF-8"));
                  BufferedReader bufreader = new BufferedReader(isr);
            ) {
                int timeByMethod = 0;
                while ((line = bufreader.readLine()) != null) {
                    // Deal with the line
                    String[] fields = line.split(" ");
                    if (isAllocation(fields[0])) {
			ObjectRecord rec = parseAllocation( fields, timeByMethod );
			heap.put(rec.get_objId(), new ObjectModel(rec.get_objId(), rec.get_type()));
                    }
                    else if (isUpdate(fields[0])) {
			timeByMethod++;
                        UpdateRecord rec = parseUpdate( fields, timeByMethod );
                        int objId = rec.get_objId();
			int fieldId = rec.get_fieldId();
			ObjectModel obj = heap.get(objId);
			if(obj.hasField(fieldId)){
			    ObjectModel.FieldData data = obj.getField(fieldId);

			    //Process data as a fact

			}

			obj.addField(fieldId, rec.get_timeByMethod(), rec.get_newTgtId());

                    } else if(isDeath(fields[0])) {
			DeathRecord rec = parseDeath( fields, timeByMethod );
			int objId = rec.get_objId();
			ObjectModel obj = heap.get(objId);
			
			//Process dead fields

			heap.remove(objId);
		    }

                    i += 1;
                    if (i % 10000 == 1) {
                        System.out.print(".");
                    } 
                }
            }
            System.out.println("");
        } catch (IOException e) {
            System.err.println( e.getClass().getName() + ": " + e.getMessage() );
            System.exit(0);
        }
    }

    private static boolean isUpdate(String op) {
        return op.equals("U");
    }

    private static boolean isAllocation( String op ) {
        return (op.equals("A") || op.equals("N") || op.equals("P") || op.equals("I"));
    }

    private static boolean isDeath(String op) {
        return op.equals("D");
    }

    private static ObjectRecord parseAllocation( String[] fields, int timeByMethod ) {
        // System.out.println("[" + fields[0] + "]");
        int objId = Integer.parseInt( fields[1], 16 );
        String type = fields[3];
        // UNUSED right now:
        // int size = Integer.parseInt( fields[2], 16 );
        // int site = Integer.parseInt( fields[4], 16 );
        // int length = Integer.parseInt( fields[5], 16 );
        // int threadId = Integer.parseInt( fields[6], 16 );
        return new ObjectRecord( 0, // Autogenerated by database
                                 objId,
                                 0, // Unknown at this point
                                 timeByMethod,
                                 0, // Unknown at this point
                                 type );
    }

    private static UpdateRecord parseUpdate( String[] fields, int timeByMethod ) {
        int oldTgtId = Integer.parseInt( fields[1], 16 );
        int objId = Integer.parseInt( fields[2], 16 );
        int newTgtId = Integer.parseInt( fields[3], 16 );
        int fieldId = 0;
        try {
            fieldId = Integer.parseInt( fields[4], 16 );
        }
        catch ( Exception e ) {
            try {
                System.out.println( String.format("parseInt failed: %d -> %s", objId, fields[4]) );
                BigInteger tmp = new BigInteger( fields[4], 16 );
                fieldId = tmp.intValue();
            }
            catch ( Exception e2 ) {
                System.err.println( e2.getClass().getName() + ": " + e2.getMessage() );
                System.exit(0);
            }
        }

	for(String s : fields)
	    System.err.println(s);
        int threadId = Integer.parseInt( fields[5], 16 );
        return new UpdateRecord( objId,
                                 oldTgtId,
                                 newTgtId,
                                 fieldId,
                                 threadId,
                                 timeByMethod );
    }

    private static DeathRecord parseDeath( String [] fields, int timeByMethod ){
	return null;
    }
}
